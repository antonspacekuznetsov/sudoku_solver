# sudoku_solver
	Программа на Python 3 решающая "судоку" не методом перебора значений, а логическими алгоритмами на основе анализа определенных данных.
Данный подход демонстрирует логику исспользуемую человеком при решении судоку.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~####~~##~~##~#####~~~####~~##~~##~##~~##
.##~~~~~##~~##~##~~##~##~~##~##~##~~##~~##
~####~~##~~##~##~~##~##~~##~####~~~##~~##
~~~~##~##~~##~##~~##~##~~##~##~##~~##~~##
~####~~~####~~#####~~~####~~##~~##~~####

~####~~~####~~##~~~~~##~~##~#####~~#####
.##~~~~~##~~##~##~~~~~##~~##~##~~~~~##~~##
~####~~##~~##~##~~~~~##~~##~####~~~#####
~~~~##~##~~##~##~~~~~~####~~##~~~~~##~~##
~####~~~####~~######~~~##~~~#####~~##~~##
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Автор Кузнецов Антон
Если у вас есть вопросы, пожелания вы можете связаться со мной по e-mail:as.ky@ya.ru или посетить мой блог 1kuznetsov.ru

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Программа является консольной. Для запуска из терминала наберите python sudoku_python.py 3 версии. Так выглядит результат работы в случае
 нахождения решения. Если решение не найдено выводится сообщение Can't solve!

{"map":"600300070000070012500000000003500400000020000900000000020000800000900500010000000","mapId":"432815"}


6   3   5   2   1   9   4   7   8   

8   9   7   6   4   5   2   3   1   

2   4   1   3   8   7   9   6   5   

3   8   2   5   6   4   1   9   7   

4   7   9   1   2   3   5   8   6   

1   5   6   7   9   8   3   2   4   

9   6   3   4   7   1   8   5   2   

7   1   8   9   5   2   6   4   3   

5   2   4   8   3   6   7   1   9 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	В программе реализованно 10 методов все которые представляют из себя обычные функции с вызывом  из основного цикла while - выполняется до
тех пор пока не будут найдены все значения во всех клетках или если все функции в течении 150 итераций не вернут ни одного значения в таком
случае будет считаться, что решение не было найдено и программа завершиться с сообщением, что решение не найдено.
Так же данный код может быть с легкостью переписан на другом языке программирования так как исспользует простой процедурный подход. При желании
может быть модернизирован и дописан для генерации головоломок судоку.

	Для решения судоку исспользуются 4 метода решения:_method1(),_method2(),_method3(),method4() все остальные методы являются
вспомогательными.
- Первый метод проходит по всем клеткам судоку и устанавливает значения по алгоритму «Выбора нет» (информацию о методах можно найти тут
http://habrahabr.ru/post/173795/ или в интернете).

- _method2() является ответвлением первого метода и вызывается из _method1(), может работать только с первым методом так как исспользует часть
его кода, основан на алгоритме «Нерезиновая». 

- Третий метод _method3() вызывается в том случае если первые два метода не нашли значений. Алгоритм «А кто, как не я?» и в список _pos_val
записываются все возможные значения которые могут находиться в клетке.

- И четвертый метод _method4() основан на алгоритме установки значения наимеение раз повторяющиеся из возможных в строке, столбце или большом
квадрате 3х3. 

	Далее слудует пошаговое описании работы программы с примерами и описанием всех методов и переменных.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
К сожаления выше перечисленные методы не способны решить абсолютно все варианты судоку и нуждаются в дополненни новыми методами
 способствующими нахождению новых значений. В отдельном файле "Statistic.txt" будет представлен отчет о работе программы.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	Варианты судоку загружаются со сторонего сайта sudoku.org.ua. В результате анализа которого было установленно, что страница
sudoku.org.ua/t/map?id=4 возвращает ответ вида
 {"map":"600300070000070012500000000003500400000020000900000000020000800000900500010000000","mapId":"432815"}
где значение id от 0 до 4 чем выше значение тем выше уровень сложности. 0 - Легкий (содержит много подсказок);
									1 - Нормальный;
									2 - Тяжелый;
									3 - Экстремальный;
									4 - Минимальный (содержит минимум 17 подсказок).

Импортируем следующие модули:
	import requests as _rq	- нам понадобиться для работы с сетью и получения данных с сайта 
	import copy,os,sys	- copy для копирования списков, os для метода очистки экрана и sys для вызова метода принудительного выхода
Объявляем переменные:
	_id="idstring" - переменная для хранении информации полученной с сайта 
	hard=4 - устанавливается значение от 0 до 4 определяет уровень сложности  
	mm=[] - список содержищий массив значений. Структура: [0, 0, 0, 6], [0, 0, 1, 5], [0, 0, 2, 9], ... первое значение mm[0][0]=0 указывает
 номер большого квадрата 3х3 немерация начинается с 0, значение mm[0][1]=0 указывает на столбец, mm[0][2]=0 - строка и mm[0][3]=6 говорит, что 
самая первая клетка содержит значение 6. Для наглядности ниже представлен пример нумерации судоку.

    0   1   2   3   4   5   6   7   8  	- нумерация вертикали
    _   _   _   _   _   _   _   _   _

0 | 6   3   5   2   1   9   4   7   8   

1 | 8   9   7   6   4   5   2   3   1   

2 | 2   4   1   3   8   7   9   6   5   

3 | 3   8   2   5   6   4   1   9   7   

4 | 4   7   9   1   2   3   5   8   6   

5 | 1   5   6   7   9   8   3   2   4   

6 | 9   6   3   4   7   1   8   5   2   

7 | 7   1   8   9   5   2   6   4   3   

8 | 5   2   4   8   3   6   7   1   9 

|
нумерация горизонтали

		3х3
===================================

 0  1   2   3   
    _   _   _  

0 | 6   3   5    

1 | 8   9   7     0 квадрат

2 | 2   4   1    
=====================================

3 | 3   8   2      

4 | 4   7   9     1 квадрат

5 | 1   5   6    
===================================== 

6 | 9   6   3   

7 | 7   1   8   2 квадрат

8 | 5   2   4   
=====================================

	_detect_count=[[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[7,0],[8,0],[9,0]] - Формируется список в котором будут храниться значения какое
количество 1ок,2ек,3ек и т.д найдено. К примеру _detect_count=[[1,4],[2,6],[3,5],[4,0],[5,0],[6,0],[7,9],[8,0],[9,0]] значений 1 найдено 4,
значений 2ек 6 штук, 7ки все найдены их 9!
	_pos_val=[] - список заполнение которого будет происходить в _method3(). [[0, 0, 2, [[1, 3, 5, 9]]], [1, 0, 4, [[1, 9]]],...
имеет аналогичную структуру как у списка mm[] только значение _pos_val[0][3] имеет вложенный список возможных значений в квадрате 0 0 2.

Определяем функции программы:
	Метод _init() производится запрос к сайту sudoku.org.ua/t/map?id=4 и формирование списка mm данными с сайта.

	global _id
	counter=0
	minicounter=0
	try:		
		link=_rq.get('http://sudoku.org.ua/t/map.php?action='+str(hard))
	except:
		print("Check Internet connection or web site is out!")
		sys.exit()
	_id=link.text

	Пытыемся получить данные, создаем запрос к сайту и записываем полученный резульат в объект link в случае невозможности установить
	соединение вызывается исключение, выводится информация на экран "проверте соединение с интернетом или сайт не доступен" и производится
	выход из программы. В случае успеха записываем строку link.text в переменную _id.
		>>>print(_id)
		{"map":"520600000000000901008000000400200700000800050900000000000091000030000020000040000","mapId":"431528"}

	for i in link.text:
		if (i=='I'):
			break
		if(str(i).isdigit()):
				detect_count(int(i))
				mm.append([detect_box(counter,minicounter),counter,minicounter,int(i)])
				minicounter+=1
		if(minicounter==9):
			minicounter=0
			counter+=1
	del link,minicounter,counter
	
	Создаем цикл по каждому элементу строки link.text. Если переменная в цикле i равна символу I то прерываем цикл, это говорит о том, что
	все значения судоку записанны в список mm. Условие if(str(i).isdigit()) проверяет если переменная i цифра то:
	вызываем метод detect_count(int(i)) в качестве параметра передаем значение переменной i, произодим добавление в конец списка mm значений
	возвращаемых методом detect_box - (возвращает значение большого квадрата ), переменных counter,minicounter, значение int(i) и удаляем
	объект link и переменные minicounter,counter. 
	







